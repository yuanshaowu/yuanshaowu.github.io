<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Git内部原理及“最佳”实践 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Git内部原理Git基础 直接记录快照，而非差异比较  Git和其他版本控制系统的主要差别在于Git对待数据的方法，其它大部分系统以文件变更列表的方式存储信息，这类系统将他们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。而Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如">
<meta property="og:type" content="article">
<meta property="og:title" content="Git内部原理及“最佳”实践">
<meta property="og:url" content="http://yoursite.com/2018/12/21/git内部原理及最佳实践/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Git内部原理Git基础 直接记录快照，而非差异比较  Git和其他版本控制系统的主要差别在于Git对待数据的方法，其它大部分系统以文件变更列表的方式存储信息，这类系统将他们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。而Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/git.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/work.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/list.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/init.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/add.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/commit.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/edit.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/editadd.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/editcommit.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/reset2.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/soft.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/mixed.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/hard.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/reset.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/branch.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/branch1.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/branch2.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/branch3.png">
<meta property="og:image" content="http://pbv0yiork.bkt.clouddn.com/image/flow.png">
<meta property="og:updated_time" content="2018-12-21T06:45:21.981Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git内部原理及“最佳”实践">
<meta name="twitter:description" content="Git内部原理Git基础 直接记录快照，而非差异比较  Git和其他版本控制系统的主要差别在于Git对待数据的方法，其它大部分系统以文件变更列表的方式存储信息，这类系统将他们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。而Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如">
<meta name="twitter:image" content="http://pbv0yiork.bkt.clouddn.com/image/git.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-git内部原理及最佳实践" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/21/git内部原理及最佳实践/" class="article-date">
  <time datetime="2018-12-21T06:49:20.317Z" itemprop="datePublished">2018-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Git内部原理及“最佳”实践
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Git内部原理"><a href="#Git内部原理" class="headerlink" title="Git内部原理"></a>Git内部原理</h1><h3 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h3><ul>
<li>直接记录快照，而非差异比较<br>  Git和其他版本控制系统的主要差别在于Git对待数据的方法，其它大部分系统以文件变更列表的方式存储信息，这类系统将他们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。而Git 把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git对待数据更像是一个快照流。</li>
</ul>
<p><img src="http://pbv0yiork.bkt.clouddn.com/image/git.png" alt="git"></p>
<ul>
<li><p>Git保证完整性<br>  Git中所有数据在存储前都计算校验和，然后以校验和来引用，Git 用以计算校验和的机制叫做 SHA-1散列（hash，哈希）。这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：24b9da6552252987aa493b52f8696cd6d3b00373。实际上，Git数据库中保存信息都是以文件内容的哈希值来索引，而不是文件名。<br>  如何计算？<br>  Git在计算校验和时，首先会创建一个头部信息然后和原始数据拼接起来。从而计算出一个40位的hash值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">header = &quot;&lt;type&gt; &quot; + content.length + &quot;\0&quot;</span><br><span class="line">hash = sha1(header + content)</span><br></pre></td></tr></table></figure>
<p>  <strong>Git十分智能，你只需要提供SHA-1的前几个字符就可以获得对应的那次提交，当然你提供的SHA-1字符数量不得少于4个，并没有歧义–也就是说，当前仓库中只有一个对象以这段SHA-1开头，默认使用七个字符，通常8到10个字符就已经足够在一个项目中避免SHA-1歧义。</strong></p>
</li>
<li><p>三种状态<br>  工作目录下的每一个文件不外乎有两种状态：已跟踪（tracked）或未跟踪（Untracked）。<br>  已跟踪的文件是指那些被纳入了版本控制的文件，在上次快照中有它们的记录，工作目录中除以跟踪文件以外的所有其他文件都属于未跟踪文件，它们既不存在于上次快照记录中，也没有放入暂存区。<br>  已提交（committed）、已修改（modified）和已暂存（staged），已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。<br>  由此引入三区：Git仓库、工作目录以及暂存区。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/work.png" alt="git"><br>Git仓库: 是Git用来保存项目元数据和对象数据库的地方（.git）。</p>
<ul>
<li><p>当在一个新目录或已有目录执行 git init 时，Git 会创建一个.git目录。 这个目录包含了几乎所有Git存储和操作的对象。该目录结构如下所示：<br><img src="http://pbv0yiork.bkt.clouddn.com/image/list.png" alt="git"></p>
<ul>
<li>config项目特有的配置选项</li>
<li>description文件仅供 GitWeb 程序使用</li>
<li>hooks包含客户端或服务端的钩子脚本</li>
<li>info包含一个全局性排除文件</li>
<li>HEAD指示目前被检出的分支(特殊的指针)</li>
<li>objects存储所有数据内容</li>
<li><p>refs存储指向分支的提交对象的指针</p>
<p><strong>index                   保存暂存区信息</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>工作目录: 是对项目的某个版本独立提取出来的内容。<br>暂存区域是一个文件，保存了下次将提交的文件列表。一般在Git仓库目录中，有时也被称作“索引”。<br>基本的git工作流程:<br>    在工作目录中修改文件<br>    暂存文件，将文件快照放入暂存区域<br>    提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录</p>
<ul>
<li>三棵树<br>树 – 文件的集合，而不是特定的数据结构<br>Git作为一个系统，是以它的一般操作来管理并操纵这三颗树的：<ul>
<li>HEAD ， 上一次提交的快照，下一次提交的父节点<br>HEAD，是当前分支引用的指针，它总是指向该分支的最后一次提交，这表示HEAD将是下次提交的父节点</li>
<li>Index， 预期的下次提交快照<br>Git将上一次检出到工作目录中的所有文件填充到索引区，他们看起来就像最初被检出时的样子，之后你会将其中一些文件替换为新版本，接着通过git commit 将它们转换为树来用作新的提交。</li>
<li>Working Directory ， 工作区<br>前两颗树以一种高效但并不直观的方式，将它们的内容存储在.git文件夹中。工作目录会将它们解包为实际的文件以便编辑。<br><strong>Git主要的目的是通过操纵三棵树来以更加连续的状态记录项目的快照</strong></li>
</ul>
</li>
</ul>
<h3 id="git-是如何运转的？"><a href="#git-是如何运转的？" class="headerlink" title="git 是如何运转的？"></a>git 是如何运转的？</h3><ul>
<li><p>初始化git 仓库（git init），创建一个文件file.txt，我们称其为该文件的v1版本<br>git为我们自动创建第一个分之master，以及指向master的一个指针HEAD<br><img src="http://pbv0yiork.bkt.clouddn.com/init.png" alt="git"><br>底层命令实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;version 1&apos; &gt; test.txt </span><br><span class="line">git hash-object -w test.txt </span><br><span class="line">83baae61804e65cc73a7201a7252750c76066a30</span><br></pre></td></tr></table></figure>
<p>此时，只有工作目录有内容</p>
</li>
<li><p>git add – 跟踪文件，获取工作目录中的内容，并将其复制到索引中<br><img src="http://pbv0yiork.bkt.clouddn.com/image/add.png" alt="git"><br>底层命令实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>git commit<br>首先，他会移除索引中的内容并将它保存一个永久的快照，<br>然后，创建一个指向该快照的提交对象，最后更新master来指向本次提交<br><img src="http://pbv0yiork.bkt.clouddn.com/image/commit.png" alt="git"></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &apos;first commit&apos; | git commit-tree d8329f 	</span><br><span class="line">fdf4fc3344e67ab068f836878b6c4951e3b15f3d</span><br></pre></td></tr></table></figure>
</li>
<li><p>对文件修改，然后提交它，会经历同样的过程<br>首先，编辑文件，版本为v2<br><img src="http://pbv0yiork.bkt.clouddn.com/image/edit.png" alt="git"><br>运行 git status， 显示changes not staged for commit – 因为索引区与工作目录之间存在不同，<br>接着，运行git add将其暂存到索引中<br><img src="http://pbv0yiork.bkt.clouddn.com/image/editadd.png" alt="git"><br>由于索引和HEAD不同，若运行git status 会看到， changes to be committed  — 下一次提交与上一次提交不同<br>最后，git commit 完成<br><img src="http://pbv0yiork.bkt.clouddn.com/image/editcommit.png" alt="git"><br>切换分支或克隆的过程也类似，当检出一个分支时，它会修改HEAD指向新的分支引用，将索引填充为该次提交的快照，然后将索引的内容复制到工作目录中。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  每次我们运行git add 、 git commit 时，Git所做的实质工作：</p>
<ul>
<li>将被改写的文件保存为数据对象</li>
<li>更新暂存区，记录树对象（通常，Git根据某一时刻暂存区所表示的状态创建并记录一个对应的树对象，如此重复便可依次记录（某个时间段内）一系列的树对象）</li>
<li>最后创建一个提交对象，指明了顶层树对象（代表当前项目快照）和父提交对象（上一次的提交对象）。 </li>
</ul>
<h3 id="找不同-–-reset-和-chekcout"><a href="#找不同-–-reset-和-chekcout" class="headerlink" title="找不同 –  reset 和 chekcout"></a>找不同 –  reset 和 chekcout</h3><h2 id="reset-做了什么？"><a href="#reset-做了什么？" class="headerlink" title="reset 做了什么？"></a>reset 做了什么？</h2><p>  为了演示下面例子，再次修改了file.txt文件并第三次提交它。现在历史看起来像：<br>    <img src="http://pbv0yiork.bkt.clouddn.com/image/reset2.png" alt="git"></p>
<ul>
<li><p>移动HEAD<br>  reset做的第一件事就是移动HEAD的指向，reset移动HEAD以及其指向的分支<br><img src="http://pbv0yiork.bkt.clouddn.com/image/soft.png" alt="git"><br><strong>它本质上是撤销上一次git commit命令</strong><br>当你运行commit时，git会创建一个新的提交，并移动HEAD所指向的分之来使其指向该提交。当你将它reset回HEAD～（HEAD的父节点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录</p>
<ul>
<li>更新索引（–mixed）<br>reset会用HEAD指向的当前快照的内容来更新索引<br><img src="http://pbv0yiork.bkt.clouddn.com/image/mixed.png" alt="git"><br>如果指定–mixed 选项，reset将会在这时停止，这也是默认行为，如果没有指定任何选项（在本例中 git reset HEAD～），这就是命令将会停止的地方。<br>由图可看出，它依然回撤销上一次的提交，还会取消暂存所有的东西，于是，我们回滚倒了所有git add 和git commit 的命令执行之前。</li>
<li>更新所有工作目录 （–hard）<br>reset要做的第三件事就是让工作目录看起来像索引，如果使用–hard选项，它将会继续这一步。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/hard.png" alt="git"><br>⚠️注意：–hard标记时reset命令唯一危险用法，它也是Git会真正地销毁数据的仅有的几个操作之一。在这种特殊的情况下，Git数据库中的一个提交内还留有该文件的v3版本，我们可以通过reflog来找回它。但是若该文件还未提交，Git仍会覆盖它从而导致无法恢复</li>
<li>总结<br>reset命令会以特定的顺序重写这三棵树，在你指定一下选项时会停止；<ul>
<li>移动HEAD分支的指向（若指定 –soft，则到此停止）</li>
<li>使索引看起来像HEAD（若未指定 –hard，则到此停止）</li>
<li>使工作目录看起来像索引<h2 id="checkout-做了什么？"><a href="#checkout-做了什么？" class="headerlink" title="checkout 做了什么？"></a>checkout 做了什么？</h2></li>
</ul>
</li>
<li>git checkout – <file>  撤销修改，用暂存区的某个文件来覆盖工作区，经常用于撤销一些修改<br>实质 ： git checkout – <file> 是用来是工作区回到上次操作git add时的样子</file></file></li>
<li>git chekout HEAD <file> 是用版本库同时覆盖暂存区和工作区，用来彻底撤销一个修改，这个命令更加危险，因为它会同时修改工作区和暂存取，且无法撤销</file></li>
</ul>
<h2 id="reset-和-checkout的区别"><a href="#reset-和-checkout的区别" class="headerlink" title="reset 和 checkout的区别"></a>reset 和 checkout的区别</h2><ul>
<li>可以实现相同的功能，比如还原本地文件，但是reset更强调“撤销”，比如撤销暂存区、撤销暂存区和本地，而checkout更强调“替换”，比如用暂存区内容替换本地，用head指向目录替换暂存区和本地。</li>
<li>reset会移动HEAD分支的指向，而checkout只会移动HEAD自身来指向另一个分支。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/reset.png" alt="git"></li>
</ul>
</li>
</ul>
<h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><p>Git的分支，其实本质上仅仅是指向提交对象的可变指针。git的默认分支是master（git init时默认创建），再多次提交操作之后，你其实已经有一个指向最后那个提交对象的master分支。它会在每次提交的操作中自动 向前移动。</p>
<ul>
<li>假设，Git仓库目前的分支及提交历史如下：<br><img src="http://pbv0yiork.bkt.clouddn.com/image/branch.png" alt="git"></li>
<li><p>如何创建分支？<br>eg： 创建test分支（创建了一个可以移动的新的指针）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test  //  这会在当前提交对象上创建一个指针</span><br></pre></td></tr></table></figure>
<p>底层命令实现：(.git/refs)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git update-ref refs/head/test sha-1</span><br></pre></td></tr></table></figure>
<p><img src="http://pbv0yiork.bkt.clouddn.com/image/branch1.png" alt="git"><br>由图可看到，有两个指向相同提交历史的分支，那么Git又是怎么知道当前在哪一个分支上呢？ – HEAD特殊指针<br>HEAD是当前分支引用的指针，它总是指向该分支上的最后一次提交，这也标示HEAD将时下一次提交的父节点。通常，理解HEAD最简单的方式，就是将它看做上一次提交的快照。<br>执行git branch test 仅仅创建了新分支，并不会自动切换倒新分支中去。<br><img src="http://pbv0yiork.bkt.clouddn.com/image/branch2.png" alt="git"></p>
<p><strong>当运行类似于 git branch (branchname) 这样的命令时，Git 实际上会运行 update-ref 命令，取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新引用中。</strong></p>
</li>
<li><p>切换分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test    // 这样，HEAD就指向了test分支</span><br></pre></td></tr></table></figure>
<p><img src="http://pbv0yiork.bkt.clouddn.com/image/branch3.png" alt="git"></p>
<ul>
<li>切换分支，实则是将HEAD指向所要切换的分支<br>这个命令做的三件事：<br>  将HEAD指向对应分支的最后一次commit<br>  将HEAD指向的commit里所有文件的snapshot替换掉Index区域里原来的内容（将工作目录恢复成master分支所指向的快照内容）<br>  将Index区域里的内容填充到Working Directory里<ul>
<li>底层实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git symbolic-ref HEAD refs/heads/test</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Git最佳实践"><a href="#Git最佳实践" class="headerlink" title="Git最佳实践"></a>Git最佳实践</h1><h3 id="git-flow-开发流程"><a href="#git-flow-开发流程" class="headerlink" title="git flow 开发流程"></a>git flow 开发流程</h3><p><img src="http://pbv0yiork.bkt.clouddn.com/image/flow.png" alt="git"></p>
<ul>
<li>Git flow 使用原则<br>  Master分支是线上稳定分支，Release通常用作测试分支，Develop分支是开发应用的主分支<br>  所有的功能开发都在Feature分支进行，然后合并到Develop分支<br>  Release分支发布后出现问题，直接在Release分支修改，避免Develop分支代码污染</li>
</ul>
<h3 id="规范git的使用"><a href="#规范git的使用" class="headerlink" title="规范git的使用"></a>规范git的使用</h3><ul>
<li>尽早并频繁地提交改动<br>经常性地提交改动可以确保不会出现特别庞大的提交，同时也可以比较精准地对应到所需要的改动上。此外，通过频繁地提交也可以比较快速地和其他开发人员来共享你的改动。同样也会避免在整合代码时出现过多的合并冲突。相反的，非常庞大的提交会加大整合代码时出现冲突的风险，解决这些冲突也会非常复杂。</li>
<li>提交对应改动<br>一次提交要包括一个相关改动。例如，对于两个错误的修复应该进行两次不同的提交。精简的提交可以让其他的开发团队人员更简单地明白其改动的用义。如果其中一次提交的改动出现了问题，也可以方便地回滚到改动之前的状态。借助暂存功能来标记相关的改动文件，Git 可以为你打造出非常精准的提交。</li>
<li>提交前测试那些改动<br>不要理所当然地认为自己完成的改动都是正确的。所有的改动一定要通过彻底地测试才表示它真正地被完成了。尽管这些改动可能仅仅是提交到了你的本地仓库中，只有你自己才能看到，但完整的测试同样是非常重要的，因为这些代码可能之后会被推送和共享到远程给其他的开发人员。</li>
<li><p>Don’t panic<br>只要你已经完成了你的工作（或者在许多情况下甚至已经添加了它git add），你的工作将不会丢失至少两周，运行命令手动清除它</p>
<!-- As long as you have committed your work (or in many cases even added it with git add) your work will not be lost for at least two weeks unless you really work at it (run commands that manually purge it).
When attempting to find your lost commits, first make sure you will not lose any current work. You should commit or stash your current work before performing any recovery efforts that might destroy your current work and perhaps take backups of it (see Backups below). After finding the commits you can reset, rebase, cherry-pick, merge, or otherwise do what is necessary to get the commit history and work tree you desire. -->
<ul>
<li><p>有三个地方可以隐藏“丢失”的变化</p>
<ul>
<li>reflog<br>Git reflog 可以查看所有分支的所有操作记录（包括提交、回退、已删除的提交操作记录等)</li>
<li>lost＆found（git fsck –unreachable）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fsck --lost-found</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通过该命令你可以看到丢掉的提交。你可以通过运行 git show [commit_hash] 查看提交之后的改变或者运行git merge [commit_hash] 来恢复到之前的提交。<br>git fsck 相对reflog是有优势的。比方说你删除一个远程的分支然后关闭仓库。 用fsck 你可以搜索和恢复已删除的远程分支</p>
<ul>
<li><p>stashed（git stash list）<br>你正在修改某个bug或者某个特性，又突然被要求展示你的工作。而你现在所做的工作还不足以提交，这个阶段你还无法进行展示（不能回到更改之前）。在这种情况下， git stash可以帮助你。stash在本质上会取走所有的变更并存储它们为以备将来使用。stash你的变更，你只需简单地运行下面的命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>希望检查stash列表，你可以运行下面的命令：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<p>  如果你想要解除stash并且恢复未提交的变更，你可以进行apply stash:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure>
<p>  每个stash都有一个标识符，一个唯一的号码,如果你只想留有余地进行apply stash，你应该给apply添加特定的标识符：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;2&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高质量的提交注释<br><a href="https://segmentfault.com/a/1190000009048911" target="_blank" rel="noopener">超链接名</a></p>
</li>
<li><p>不要提交不完整的改动<br>虽然原则上来说不要提交一些还没有完成的改动，但是对于一个非常庞大的新功能来说，也并不意味着你必须整体完成这个功能后才可以提交。恰恰相反，你必须把那些改动正确地分割成一些有意义的逻辑模块来进行频繁地提交。如果你仅仅是因为急着想要下班，或者是想要得到一个干净的工作副本（比如想要切换到另一个分支上），你可以利用 Git 所提供的储藏（Stash）功能来解决这些问题。切记不要把那些不完整的改动提交到仓库中</p>
</li>
<li><p>Release tagging  – 打tag</p>
</li>
<li>使用有用的工具<br>强烈安利sourceTree</li>
</ul>
<h3 id="推荐git相关内容"><a href="#推荐git相关内容" class="headerlink" title="推荐git相关内容"></a>推荐git相关内容</h3><p><a href="https://bingohuang.gitbooks.io/progit2/content/" target="_blank" rel="noopener">Pro Git</a><br><a href="http://sethrobertson.github.io/GitBestPractices/" target="_blank" rel="noopener">Git 最佳实践</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/21/git内部原理及最佳实践/" data-id="cjpxocsih0000qgxa71i4a46a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/12/21/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/21/git内部原理及最佳实践/">Git内部原理及“最佳”实践</a>
          </li>
        
          <li>
            <a href="/2018/12/21/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>